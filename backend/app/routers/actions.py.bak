"""
Actions API Router
Intelligent action triage, simulation, and execution
"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Dict, Optional, Any
from datetime import datetime
import logging
import time
import hashlib

from app.db.db import fetch, fetchrow, execute
from app.ai.triage_engine import generate_triage_queue, persist_triage_to_queue
from app.ai.application_ml import extract_application_features, predict_stage_progression

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/actions", tags=["actions"])


# ============================================================================
# Request/Response Models
# ============================================================================

class TriageRequest(BaseModel):
    limit: Optional[int] = 5
    filters: Optional[Dict[str, Any]] = None


class TriageItem(BaseModel):
    id: Optional[int] = None
    application_id: str
    applicant_name: str
    stage: str
    action_type: str
    reason: str
    priority: float
    expected_gain: Optional[float] = None
    artifacts: Optional[Dict[str, Any]] = None
    expires_at: Optional[str] = None


class TriageResponse(BaseModel):
    queue: List[TriageItem]
    generated_at: str
    count: int


class SimulateRequest(BaseModel):
    queue_id: Optional[int] = None
    application_id: Optional[str] = None
    action_type: str


class SimulateResponse(BaseModel):
    artifacts: Dict[str, Any]
    recommended: bool
    expected_gain: float
    reason: str


class ExecuteRequest(BaseModel):
    queue_id: Optional[int] = None
    application_id: str
    action_type: str
    artifacts: Optional[Dict[str, Any]] = None
    metadata: Optional[Dict[str, Any]] = None


class ExecuteResponse(BaseModel):
    ok: bool
    execution_id: int
    result: str
    message: str


class SessionPatchRequest(BaseModel):
    delta: Dict[str, Any]


# ============================================================================
# Session Management
# ============================================================================

@router.get("/session")
async def get_session(user_id: str = "mock-user-id"):  # TODO: Get from auth
    """
    Get user session context.

    Returns:
        session_ctx: Current session state
    """
    try:
        row = await fetchrow(
            "SELECT session_ctx FROM user_session_memory WHERE user_id = $1",
            user_id
        )

        if row:
            return {"session_ctx": row['session_ctx']}
        else:
            # Initialize empty session
            default_ctx = {
                "activeStage": None,
                "viewedApplications": [],
                "lastTriageIds": [],
                "preferences": {"comms": "email"}
            }

            await execute(
                """
                INSERT INTO user_session_memory (user_id, session_ctx)
                VALUES ($1, $2)
                ON CONFLICT (user_id) DO NOTHING
                """,
                user_id,
                default_ctx
            )

            return {"session_ctx": default_ctx}

    except Exception as e:
        logger.exception(f"Failed to get session: {e}")
        raise HTTPException(status_code=500, detail=f"Session fetch failed: {str(e)}")


@router.patch("/session")
async def patch_session(
    request: SessionPatchRequest,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """
    Update session context (merge delta).

    Args:
        delta: Partial update to session_ctx

    Returns:
        ok: Success indicator
    """
    try:
        # Merge delta into existing session
        await execute(
            """
            UPDATE user_session_memory
            SET session_ctx = session_ctx || $1::jsonb,
                updated_at = NOW()
            WHERE user_id = $2
            """,
            request.delta,
            user_id
        )

        return {"ok": True}

    except Exception as e:
        logger.exception(f"Failed to patch session: {e}")
        raise HTTPException(status_code=500, detail=f"Session update failed: {str(e)}")


# ============================================================================
# Triage Queue Generation
# ============================================================================

@router.post("/triage", response_model=TriageResponse)
async def generate_triage(
    request: TriageRequest,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """
    Generate prioritized action queue using sophisticated triage engine.

    Priority formula:
    priority = (impact_weight * conversion_delta) +
               (urgency_weight * stage_sla_breach_risk) +
               (freshness_weight * engagement_decay)

    Returns:
        queue: List of TriageItems sorted by priority (descending)
        generated_at: Timestamp
        count: Number of items
    """
    start_time = time.time()

    try:
        logger.info(f"Generating triage for user {user_id}, limit={request.limit}")

        # Generate triage queue using ML engine
        triage_items = await generate_triage_queue(
            user_id=user_id,
            limit=request.limit or 5,
            filters=request.filters
        )

        # Persist to database
        if triage_items:
            await persist_triage_to_queue(user_id, triage_items)

        # Convert to response model
        queue = [TriageItem(**item) for item in triage_items]

        latency_ms = int((time.time() - start_time) * 1000)

        # Log telemetry
        await execute(
            """
            INSERT INTO ai_events (user_id, event_type, model, latency_ms, payload_json)
            VALUES ($1, $2, $3, $4, $5)
            """,
            user_id,
            "triage",
            "triage_engine",
            latency_ms,
            {
                "count": len(queue),
                "limit": request.limit,
                "filters": request.filters
            }
        )

        logger.info(f"Generated {len(queue)} triage items in {latency_ms}ms")

        return TriageResponse(
            queue=queue,
            generated_at=datetime.now().isoformat(),
            count=len(queue)
        )

    except Exception as e:
        logger.exception(f"Triage generation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Triage failed: {str(e)}")


# ============================================================================
# Action Simulation (Preview)
# ============================================================================

@router.post("/simulate", response_model=SimulateResponse)
async def simulate_action(
    request: SimulateRequest,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """
    Simulate an action to preview artifacts without executing.

    Used for "preview" functionality in UI before sending.

    Args:
        queue_id: Optional queue item ID (if from queue)
        application_id: Required if not from queue
        action_type: Type of action to simulate

    Returns:
        artifacts: Generated message/script/etc
        recommended: Whether this action is recommended
        expected_gain: Expected probability increase
        reason: Why this action is recommended
    """
    try:
        # Get application details
        if request.queue_id:
            # From queue
            queue_item = await fetchrow(
                "SELECT * FROM action_queue WHERE id = $1 AND user_id = $2",
                request.queue_id,
                user_id
            )
            if not queue_item:
                raise HTTPException(status_code=404, detail="Queue item not found")

            app_id = str(queue_item['application_id'])
            artifacts = queue_item['artifacts']
            expected_gain = float(queue_item['expected_gain'] or 0.0)
            reason = queue_item['reason']

        else:
            # Direct simulation
            if not request.application_id:
                raise HTTPException(status_code=400, detail="application_id required")

            app_id = request.application_id

            # Generate artifacts on-the-fly
            features = await extract_application_features(app_id)
            prediction = predict_stage_progression(features)

            from app.ai.triage_engine import (
                generate_artifacts,
                determine_urgency_context,
                generate_action_reason
            )

            stage = features.get('stage', 'unknown')
            urgency_context = determine_urgency_context(features, stage)
            reason = generate_action_reason(request.action_type, features, stage, urgency_context)
            artifacts = generate_artifacts(request.action_type, features, reason, prediction)

            # Rough estimate of expected gain
            expected_gain = 0.1  # TODO: More sophisticated estimate

        return SimulateResponse(
            artifacts=artifacts,
            recommended=expected_gain > 0.05,
            expected_gain=expected_gain,
            reason=reason
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Simulation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Simulation failed: {str(e)}")


# ============================================================================
# Action Execution
# ============================================================================

@router.post("/execute", response_model=ExecuteResponse)
async def execute_action(
    request: ExecuteRequest,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """
    Execute an action (send email, log call, flag, etc).

    For Phase A:
    - Email: Logs as "sent" (actual sending deferred to integration)
    - Call: Logs as "sent" (assumes manual call)
    - Flag: Marks application for review
    - Unblock: Logs blocker removal

    Args:
        queue_id: Optional queue item ID
        application_id: Required
        action_type: Type of action
        artifacts: Optional custom artifacts (overrides queue)
        metadata: Optional execution metadata

    Returns:
        ok: Success indicator
        execution_id: ID of execution record
        result: 'sent'|'failed'|'skipped'
        message: Human-readable result
    """
    start_time = time.time()

    try:
        logger.info(f"Executing action: {request.action_type} for {request.application_id}")

        # Validate application exists
        app_row = await fetchrow(
            "SELECT id, stage FROM applications WHERE id = $1",
            request.application_id
        )
        if not app_row:
            raise HTTPException(status_code=404, detail="Application not found")

        # Get artifacts (from request or queue)
        artifacts = request.artifacts
        if not artifacts and request.queue_id:
            queue_item = await fetchrow(
                "SELECT artifacts FROM action_queue WHERE id = $1 AND user_id = $2",
                request.queue_id,
                user_id
            )
            if queue_item:
                artifacts = queue_item['artifacts']

        # Execute based on action type
        result = "sent"
        message = ""

        if request.action_type == "email":
            # Phase A: Log as sent (actual email sending deferred)
            # Future: Integrate with SendGrid/Mailgun
            message = "Email logged as sent (integration pending)"
            result = "simulated"  # Mark as simulated for now

        elif request.action_type == "call":
            # Phase A: Log call as completed
            message = "Call logged (manual execution)"
            result = "sent"

        elif request.action_type == "flag":
            # Mark application as flagged
            await execute(
                "UPDATE applications SET priority = 'high' WHERE id = $1",
                request.application_id
            )
            message = "Application flagged for review"
            result = "sent"

        elif request.action_type == "unblock":
            # Log unblock action (specific unblocking logic TBD)
            message = "Blocker removal logged"
            result = "sent"

        else:
            raise HTTPException(status_code=400, detail=f"Unknown action type: {request.action_type}")

        # Insert execution record
        execution_id = await fetchrow(
            """
            INSERT INTO action_executions
                (queue_id, user_id, application_id, action_type, result, metadata)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING id
            """,
            request.queue_id,
            user_id,
            request.application_id,
            request.action_type,
            result,
            {
                **(request.metadata or {}),
                "artifacts": artifacts,
                "executed_via": "api"
            }
        )

        # Remove from queue if executed via queue
        if request.queue_id:
            await execute(
                "DELETE FROM action_queue WHERE id = $1",
                request.queue_id
            )

        latency_ms = int((time.time() - start_time) * 1000)

        # Log telemetry
        await execute(
            """
            INSERT INTO ai_events (user_id, event_type, model, latency_ms, payload_json)
            VALUES ($1, $2, $3, $4, $5)
            """,
            user_id,
            "action_execution",
            request.action_type,
            latency_ms,
            {
                "application_id": request.application_id,
                "action_type": request.action_type,
                "result": result
            }
        )

        logger.info(f"Action executed successfully: {execution_id['id']}, result={result}")

        return ExecuteResponse(
            ok=True,
            execution_id=int(execution_id['id']),
            result=result,
            message=message
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Execution failed: {e}")

        # Log failed execution
        try:
            await execute(
                """
                INSERT INTO action_executions
                    (user_id, application_id, action_type, result, metadata)
                VALUES ($1, $2, $3, $4, $5)
                """,
                user_id,
                request.application_id,
                request.action_type,
                "failed",
                {"error": str(e)}
            )
        except:
            pass

        raise HTTPException(status_code=500, detail=f"Execution failed: {str(e)}")


# ============================================================================
# Queue Management
# ============================================================================

@router.get("/queue")
async def get_queue(user_id: str = "mock-user-id"):  # TODO: Get from auth
    """
    Get current action queue for user.

    Returns items sorted by priority (descending).
    """
    try:
        rows = await fetch(
            """
            SELECT
                aq.*,
                p.first_name || ' ' || p.last_name AS applicant_name
            FROM action_queue aq
            JOIN applications a ON a.id = aq.application_id
            JOIN people p ON p.id = a.person_id
            WHERE aq.user_id = $1
              AND (aq.expires_at IS NULL OR aq.expires_at > NOW())
            ORDER BY aq.priority DESC, aq.created_at ASC
            """,
            user_id
        )

        queue = [dict(row) for row in rows]

        return {
            "queue": queue,
            "count": len(queue)
        }

    except Exception as e:
        logger.exception(f"Failed to get queue: {e}")
        raise HTTPException(status_code=500, detail=f"Queue fetch failed: {str(e)}")


@router.delete("/queue/{queue_id}")
async def remove_from_queue(
    queue_id: int,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """Remove item from queue (skip/dismiss)."""
    try:
        result = await execute(
            "DELETE FROM action_queue WHERE id = $1 AND user_id = $2",
            queue_id,
            user_id
        )

        return {"ok": True, "deleted": result == "DELETE 1"}

    except Exception as e:
        logger.exception(f"Failed to remove from queue: {e}")
        raise HTTPException(status_code=500, detail=f"Remove failed: {str(e)}")


# ============================================================================
# Analytics / History
# ============================================================================

@router.get("/executions")
async def get_execution_history(
    limit: int = 20,
    user_id: str = "mock-user-id"  # TODO: Get from auth
):
    """
    Get recent action execution history.

    Returns last N executions for user.
    """
    try:
        rows = await fetch(
            """
            SELECT
                ae.*,
                p.first_name || ' ' || p.last_name AS applicant_name,
                a.stage
            FROM action_executions ae
            JOIN applications a ON a.id = ae.application_id
            JOIN people p ON p.id = a.person_id
            WHERE ae.user_id = $1
            ORDER BY ae.executed_at DESC
            LIMIT $2
            """,
            user_id,
            limit
        )

        executions = [dict(row) for row in rows]

        return {
            "executions": executions,
            "count": len(executions)
        }

    except Exception as e:
        logger.exception(f"Failed to get execution history: {e}")
        raise HTTPException(status_code=500, detail=f"History fetch failed: {str(e)}")
